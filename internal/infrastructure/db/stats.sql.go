// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: stats.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getCoinPercentiles = `-- name: GetCoinPercentiles :one
WITH stats AS (
    SELECT 
        c.id,
        c.max_value,
        c.mintage,
        c.weight_g,
        c.diameter_mm,
        PERCENT_RANK() OVER (ORDER BY c.max_value) as value_percentile,
        PERCENT_RANK() OVER (ORDER BY c.mintage DESC) as rarity_percentile, -- Lower mintage = higher rarity, so DESC for "rarity score"
        PERCENT_RANK() OVER (ORDER BY c.weight_g) as weight_percentile,
        PERCENT_RANK() OVER (ORDER BY c.diameter_mm) as size_percentile
    FROM coins c
    WHERE c.sold_at IS NULL -- Compare only with collection
)
SELECT 
    value_percentile,
    rarity_percentile,
    weight_percentile,
    size_percentile
FROM stats
WHERE id = $1
`

type GetCoinPercentilesRow struct {
	ValuePercentile  float64 `json:"value_percentile"`
	RarityPercentile float64 `json:"rarity_percentile"`
	WeightPercentile float64 `json:"weight_percentile"`
	SizePercentile   float64 `json:"size_percentile"`
}

func (q *Queries) GetCoinPercentiles(ctx context.Context, id pgtype.UUID) (GetCoinPercentilesRow, error) {
	row := q.db.QueryRow(ctx, getCoinPercentiles, id)
	var i GetCoinPercentilesRow
	err := row.Scan(
		&i.ValuePercentile,
		&i.RarityPercentile,
		&i.WeightPercentile,
		&i.SizePercentile,
	)
	return i, err
}

const getCollectionGradeDistribution = `-- name: GetCollectionGradeDistribution :many
SELECT 
    grade, 
    COUNT(*) as count
FROM coins
WHERE 
    grade != '' 
    AND sold_at IS NULL
GROUP BY grade
ORDER BY grade
`

type GetCollectionGradeDistributionRow struct {
	Grade pgtype.Text `json:"grade"`
	Count int64       `json:"count"`
}

func (q *Queries) GetCollectionGradeDistribution(ctx context.Context) ([]GetCollectionGradeDistributionRow, error) {
	rows, err := q.db.Query(ctx, getCollectionGradeDistribution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionGradeDistributionRow
	for rows.Next() {
		var i GetCollectionGradeDistributionRow
		if err := rows.Scan(&i.Grade, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCollectionYearDistribution = `-- name: GetCollectionYearDistribution :many
SELECT 
    year, 
    COUNT(*) as count
FROM coins
WHERE 
    year > 0 
    AND sold_at IS NULL
GROUP BY year
ORDER BY year
`

type GetCollectionYearDistributionRow struct {
	Year  pgtype.Int4 `json:"year"`
	Count int64       `json:"count"`
}

func (q *Queries) GetCollectionYearDistribution(ctx context.Context) ([]GetCollectionYearDistributionRow, error) {
	rows, err := q.db.Query(ctx, getCollectionYearDistribution)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCollectionYearDistributionRow
	for rows.Next() {
		var i GetCollectionYearDistributionRow
		if err := rows.Scan(&i.Year, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

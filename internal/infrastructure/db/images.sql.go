// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: images.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCoinImage = `-- name: CreateCoinImage :one
INSERT INTO coin_images (
    coin_id,
    image_type,
    side,
    path,
    extension,
    size,
    width,
    height,
    mime_type,
    original_filename
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING id, coin_id, image_type, side, path, extension, size, width, height, mime_type, original_filename, created_at, updated_at
`

type CreateCoinImageParams struct {
	CoinID           pgtype.UUID `json:"coin_id"`
	ImageType        ImageType   `json:"image_type"`
	Side             CoinSide    `json:"side"`
	Path             string      `json:"path"`
	Extension        string      `json:"extension"`
	Size             int64       `json:"size"`
	Width            int32       `json:"width"`
	Height           int32       `json:"height"`
	MimeType         string      `json:"mime_type"`
	OriginalFilename pgtype.Text `json:"original_filename"`
}

func (q *Queries) CreateCoinImage(ctx context.Context, arg CreateCoinImageParams) (CoinImage, error) {
	row := q.db.QueryRow(ctx, createCoinImage,
		arg.CoinID,
		arg.ImageType,
		arg.Side,
		arg.Path,
		arg.Extension,
		arg.Size,
		arg.Width,
		arg.Height,
		arg.MimeType,
		arg.OriginalFilename,
	)
	var i CoinImage
	err := row.Scan(
		&i.ID,
		&i.CoinID,
		&i.ImageType,
		&i.Side,
		&i.Path,
		&i.Extension,
		&i.Size,
		&i.Width,
		&i.Height,
		&i.MimeType,
		&i.OriginalFilename,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listCoinImagesByCoinID = `-- name: ListCoinImagesByCoinID :many
SELECT id, coin_id, image_type, side, path, extension, size, width, height, mime_type, original_filename, created_at, updated_at FROM coin_images
WHERE coin_id = $1
ORDER BY created_at ASC
`

func (q *Queries) ListCoinImagesByCoinID(ctx context.Context, coinID pgtype.UUID) ([]CoinImage, error) {
	rows, err := q.db.Query(ctx, listCoinImagesByCoinID, coinID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoinImage
	for rows.Next() {
		var i CoinImage
		if err := rows.Scan(
			&i.ID,
			&i.CoinID,
			&i.ImageType,
			&i.Side,
			&i.Path,
			&i.Extension,
			&i.Size,
			&i.Width,
			&i.Height,
			&i.MimeType,
			&i.OriginalFilename,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoinImagesByCoinIDs = `-- name: ListCoinImagesByCoinIDs :many
SELECT id, coin_id, image_type, side, path, extension, size, width, height, mime_type, original_filename, created_at, updated_at FROM coin_images
WHERE coin_id = ANY($1::uuid[])
ORDER BY coin_id, created_at ASC
`

func (q *Queries) ListCoinImagesByCoinIDs(ctx context.Context, dollar_1 []pgtype.UUID) ([]CoinImage, error) {
	rows, err := q.db.Query(ctx, listCoinImagesByCoinIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CoinImage
	for rows.Next() {
		var i CoinImage
		if err := rows.Scan(
			&i.ID,
			&i.CoinID,
			&i.ImageType,
			&i.Side,
			&i.Path,
			&i.Extension,
			&i.Size,
			&i.Width,
			&i.Height,
			&i.MimeType,
			&i.OriginalFilename,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
